[{"title":"Python基础知识（一）","date":"2019-12-25T13:54:13.000Z","path":"2019/12/25/Python基础知识（一）/","text":"一、常量1. 定义 python与java最大的区别就是无需定义数据类型 1message = ‘hello world’ 2. Python 命名 只允许字母、数字、下划线，不能以数字开头 不能包含空格 不能以 Python 的关键字和函数名作为变量名 变量名应简短且具描述性 慎用小写字母l和大写字母O 3. 符串 python中在括号中的都是字符串 字符串定义可以是单引号跟双引号 通常检验不区分大小写的情况下是否相同，常用方法：title()、大写 upper()、小写 lower()等 1234# title() 会把首字母变成大写msg = 'hello python'print(msg.title())#Hello Python 使用 rstrip() 去除字符串开头和结尾的空格，去除开头 lstrip()、去除结尾 strip() 灵活使用单双引号，防止字符串中存在单双引号而产生语法错误 使用制表符或换行符来添加空白 12345print(\"Languages:\\n\\tPython\\n\\tC\\n\\tJavaScript\") #Languages: # Python# C # JavaScript 4. 数字 可用基本的运算字符直接拼接计算 数字拼接字符串，需要使用 str(num) 函数进行指定 123msg = '该篇文章字数为：'num = 100print(msg + str(num)) Python使用两个乘号表示乘方运算 12print(2 ** 10)#1024 5. 除法 使用斜杆(/)做除法时，注意python2 和python3 的区别。在python2 中3/2，得出整除的1；而在python3 中的3/2，则会得出1.5 6. 注释 使用#号进行注释","link":"","tags":[{"name":"Python","slug":"Python","permalink":"www.chenzhesheng.cc/tags/Python/"}]},{"title":"Android触摸事件传递机制","date":"2019-07-01T02:06:00.000Z","path":"2019/07/01/Android触摸事件传递机制/","text":"前言：在Android开发中，经常会遇到触摸事件冲突，比如ViewPager的轮播图跟Fragment的划动事件冲突，或者轮播图跟下拉事件冲突，自定义view的事件处理等，本文章将会详细介绍Activity、View、ViewGroup三者的触摸事件传递机制，传递包括三个阶段：分发、拦截、消费。 本文章将会详细介绍Activity、View、ViewGroup三者的触摸事件传递机制，传递包括三个阶段：分发、拦截、消费。 一.触摸事件的类型触摸事件对应的是 MotionEvent 类，事件类型主要有三种： ACTION_DOWN：用户按下操作，表示一次触摸事件的开始。 ACTION_MOVE：在按下的情况下，进行移动。轻微的移动都会传递到该事件。 ACTION_UP：用户手指离开屏幕，表示一次触摸事件的注 ：如果用户仅仅的是点击而已，则只会执行到 ACTION_DOWN 和 ACTION_UP 两个事件，不会执行到 ACTION_MOVE 事件。所以 ACTION_DOWN 和 ACTION_UP 是事件是必须的。 二.触摸事件的传递阶段1.分发（Dispatch）在Android系统中所有的触摸事件都是由 dispatchTouchEvent 方法进行分发的。该方法中判断事件是被消费（return true），还是继续分发给子视图处理（return super.dispatchTouchEvent），如果当前视图是ViewGroup或者其子类，则会调用onInterceptTouchEvent 判断是否截拦。 1234@Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 2.截拦（Intercept）事件的截拦 InterceptTouchEvent 只存在于ViewGroup及其子类，activity和View是不存在该方法。该方法判断事件是被截拦 （return true）并交给自身的 OnToucEvent 方法进行消费，还是继续传递给子视图（return super.InterceptTouchEvent 或者 return false）。 1234@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return super.onInterceptTouchEvent(ev);&#125; 3.消费（Consume）事件的消费通过 OnTouchEvent 方法判断，是被消费（return true）,还是不处理（return false）并将事件传递给父视图的 OnTouchEvent 方法进行处理。 1234@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; return super.onTouchEvent(event);&#125; 所有拥有事件传递能力的类：Activity： 拥有dispatchTouchEvent 、OnTouchEventViewGroup： 拥有dispatchTouchEvent 、OnInterceptTouchEvent 、OnTouchEventView：拥有dispatchTouchEvent 、OnTouchEvent 三、View的事件传递机制3.1 dome虽然说ViewGroup是View的子类，但是这是说的View指的是除ViewGroup之外的View控件子类，首先定义一个MyTextView继承TextView，打印每次事件的触发以变了解事件传递的流程。 MyTextView 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyTextView extends TextView &#123; private String tag = \"MyTextView\"; public MyTextView(Context context) &#123; super(context); &#125; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"dispatchTouchEvent ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"dispatchTouchEvent ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"dispatchTouchEvent ACTION_DOWN\"); break; &#125; return super.dispatchTouchEvent(event); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"onTouchEvent ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"onTouchEvent ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"onTouchEvent ACTION_DOWN\"); break; &#125; return super.onTouchEvent(event); &#125;&#125; 定义一个MainActivity来展现这个MyTextView，同时设置点击（onClick）和触摸（onTouch）监听。MainActivity 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MainActivity extends AppCompatActivity implements View.OnClickListener,View.OnTouchListener&#123; private MyTextView mMyTextView; private String tag = \"MainActiviy\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mMyTextView = findViewById(R.id.text_view); // 点击监听 mMyTextView.setOnClickListener(this); // 触碰监听 mMyTextView.setOnTouchListener(this); &#125; // MyTextView 点击事件 @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.text_view: Log.i(tag, \"MyTextView onClick\"); break; &#125; &#125; // MyTextView 触碰事件 @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; switch (motionEvent.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"MyTextView onTouch ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"MyTextView onTouch ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"MyTextView onTouch ACTION_DOWN\"); break; &#125; return false; &#125; // Activity 的事件分发 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"dispatchTouchEvent ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"dispatchTouchEvent ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"dispatchTouchEvent ACTION_DOWN\"); break; &#125; return super.dispatchTouchEvent(ev); &#125; // Activity 的事件消费 @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"onTouchEvent ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"onTouchEvent ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"onTouchEvent ACTION_DOWN\"); break; &#125; return super.onTouchEvent(event); &#125;&#125; 3.2 打印日志运行后，点击Text View反馈的打印日志 12345678903-28 08:05:14.824 1219-1219/com.mvp.chenzhesheng.androidadvance I/MainActiviy: dispatchTouchEvent ACTION_DOWN03-28 08:05:14.824 1219-1219/com.mvp.chenzhesheng.androidadvance I/MyTextView: dispatchTouchEvent ACTION_DOWN03-28 08:05:14.824 1219-1219/com.mvp.chenzhesheng.androidadvance I/MainActiviy: MyTextView onTouch ACTION_DOWN03-28 08:05:14.824 1219-1219/com.mvp.chenzhesheng.androidadvance I/MyTextView: onTouchEvent ACTION_DOWN03-28 08:05:15.034 1219-1219/com.mvp.chenzhesheng.androidadvance I/MainActiviy: dispatchTouchEvent ACTION_UP03-28 08:05:15.034 1219-1219/com.mvp.chenzhesheng.androidadvance I/MyTextView: dispatchTouchEvent ACTION_UP03-28 08:05:15.034 1219-1219/com.mvp.chenzhesheng.androidadvance I/MainActiviy: MyTextView onTouch ACTION_UP03-28 08:05:15.034 1219-1219/com.mvp.chenzhesheng.androidadvance I/MyTextView: onTouchEvent ACTION_UP03-28 08:05:15.044 1219-1219/com.mvp.chenzhesheng.androidadvance I/MainActiviy: MyTextView onClick dispatchTouchEvent 、 OnTouchEvent 这两个方法的返回值存在三种情况： 直接返回true。 直接返回false。 返回父类同名方法，super.dispatchTouchEvent 或者 super.OnTouchEvent。 由于拥有不同的返回值，所以事件传递流程也有不同，经过不断修改返回值测试，最终得到了点击事件的流程图，ACTION_DOWN 和 ACTION_UP 事件的传递流程是相同的。 3.3 事件传递流程图从上面的流程图可以得出结论： 触摸事件是从 dispatchTouchEvent 开始的，默认返回父类同名方法 super ，事件将会依照嵌套层次从外向内传递（ MainActivity 到 MyTextView ），到达最内层的 View 时，将由 View 的 OnTouchEvent 方法处理，该方法返回 true 时进行消费不再传递，返回 false 时再由内向外传递，由外层的 OnTouchEvent 处理。 如果外层向内层传递过程中，人为干扰返回 true 消费，则不会继续继续像内部传递。 View 的事件控制顺序先执行 onTouch 再执行 onClick ，如果 onTouch 返回 true 消费，则不会继续传递，也不会执行 onClick 方法。 四、ViewGroup的事件传递机制4.1 domeViewGroup 是 View 的控件容器存在，拥有 dispatchTouchEvent 、 onInterceptTouchEvent 和 onTouchEvent 三个方法，比 View 多了一个 onInterceptTouchEvent 方法。为了更好的观察，我们需要自定义 MyRelativeLayout 继承 RelativeLayout 。 MyRelativeLayout类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MyRelativeLayout extends RelativeLayout &#123; private final static String tag = \"MyRelativeLayout\"; public MyRelativeLayout(Context context) &#123; super(context); &#125; public MyRelativeLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"dispatchTouchEvent ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"dispatchTouchEvent ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"dispatchTouchEvent ACTION_DOWN\"); break; &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"onInterceptTouchEvent ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"onInterceptTouchEvent ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"onInterceptTouchEvent ACTION_DOWN\"); break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_UP: Log.i(tag, \"onTouchEvent ACTION_UP\"); break; case MotionEvent.ACTION_MOVE: Log.i(tag, \"onTouchEvent ACTION_MOVE\"); break; case MotionEvent.ACTION_DOWN: Log.i(tag, \"onTouchEvent ACTION_DOWN\"); break; &#125; return super.onTouchEvent(event); &#125;&#125; main_activity.xml 文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;com.mvp.chenzhesheng.androidadvance.MyRelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;com.mvp.chenzhesheng.androidadvance.MyTextView android:id=\"@+id/text_view\" android:clickable=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\"&lt;/com.mvp.chenzhesheng.androidadvance.MyRelativeLayout&gt; 4.2 打印日志1234567891011121304-02 08:47:57.980 1030-1030/com.mvp.chenzhesheng.androidadvance I/MainActiviy: dispatchTouchEvent ACTION_DOWN04-02 08:47:58.000 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyRelativeLayout: dispatchTouchEvent ACTION_DOWN04-02 08:47:58.000 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyRelativeLayout: onInterceptTouchEvent ACTION_DOWN04-02 08:47:58.000 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyTextView: dispatchTouchEvent ACTION_DOWN04-02 08:47:58.010 1030-1030/com.mvp.chenzhesheng.androidadvance I/MainActiviy: MyTextView onTouch ACTION_DOWN04-02 08:47:58.010 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyTextView: onTouchEvent ACTION_DOWN04-02 08:47:58.200 1030-1030/com.mvp.chenzhesheng.androidadvance I/MainActiviy: dispatchTouchEvent ACTION_UP04-02 08:47:58.200 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyRelativeLayout: dispatchTouchEvent ACTION_UP04-02 08:47:58.200 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyRelativeLayout: onInterceptTouchEvent ACTION_UP04-02 08:47:58.200 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyTextView: dispatchTouchEvent ACTION_UP04-02 08:47:58.210 1030-1030/com.mvp.chenzhesheng.androidadvance I/MainActiviy: MyTextView onTouch ACTION_UP04-02 08:47:58.210 1030-1030/com.mvp.chenzhesheng.androidadvance I/MyTextView: onTouchEvent ACTION_UP04-02 08:47:58.260 1030-1030/com.mvp.chenzhesheng.androidadvance I/MainActiviy: MyTextView onClick 可以看到 MainActivity 和 MyTextView 的事件传递处理中添加了一层 MyRelativeLayout 。通过不同返回值测试，得到一套流程图。 4.3 流程图从上面的流程图可以得出结论： 触摸事件传递是从 Activity 传递到 ViewGroup ,再传递到 View 。如果中间没有 ViewGroup 则直接从 Activity 传递到 View 。 ViewGroup 通过 onInterceptTouchEvent 方法对事件进行截拦，如果返回 false 或者 super.onInterceptTouchEvent ，则事件会继续传递给子 View 。 子 View 中对事件进行消费后，ViewGroup 将不会接收到任何事件。 五.总结 事件分发是由外到内，从 Activity 到具体的子 View ； 事件处理消费是由内到外，从子 View 到最外层 Activity ； 事件拦截只存在于 ViewGroup 中； 掌握事件传递机制可以更好的进行事件处理，无论是自定义 View 还是阅读 Framework 层源码都需要对事件传递进行学习，才能更精致的开发应用。","link":"","tags":[{"name":"Android","slug":"Android","permalink":"www.chenzhesheng.cc/tags/Android/"}]},{"title":"基于vmvare12虚拟机CentOS 7系统下搭建SVN版本控制系统","date":"2019-01-30T08:21:37.000Z","path":"2019/01/30/基于vmvare12虚拟机CentOS 7系统下搭建SVN/","text":"如果你有空闲主机，放着吃尘，如果你想拥有属于自己的云存储，永久存储自己的文档，那么我建议你看看这篇文章。 虚拟机版本：vmvare 12主宿机系统：Windows 7虚拟机系统：CentOS 7 关于安装虚拟机的部分跳过，操作相对简单，网上有很多教程，大同小异。一、安装CentOS 7系统1.1 点击文件 - 新建虚拟机 - 典型 - 下一步 1.2 安装程序光盘映像文件 - 下一步提前准备好的iso系统镜像文件，底部提供网盘下载链接。 1.3 填写好登陆用户名与密码 - 下一步账号密码用于登陆到系统的。 1.4 选择虚拟机存储位置 - 下一步机械硬盘不要存储在c盘，不然装不下。 1.5 指定存储大小由于我们是用于存储文件的，有多大就用多大，不回占用硬盘的使用率，没有用到存储空间会释放出来。 1.6 点击自定义硬件 - 把网络适配器更改为桥接模式桥接模式不用勾复制物理网络连接状态，如果此主机仅用于存储，可以把其他配置提到最优。完成，进入下一步。** 如果出现”Intel VT-x 处于禁用状态”错误，需要先进入到主机的bios界面，把 intel vt 虚拟化设置为开启状态。具体打开方式问度娘，因为厂商不同，打开方式不同。** 二、安装svn版本控制登陆到系统后，修改系统语言、连接网络都在设置里面操作，右键桌面打开终端 2.1 获取root权限进入到管理员角色，拥有root权限可以对很多系统文件夹进行操作。su root输入登陆密码，回车(密码是隐藏的，看不到*号照常输入就行） 2.2 安装svnyum install -y subversion通过使用yum 可以简单轻松的安装svn。 2.3 检验svn是否安装成功svnserve --version通过查看svn版本进行建议，打印出来不是报错信息，就说明安装成功，svnserve是svn服务的名称。 2.4 创建版本库mkdir /home/svnsvnadmin create /home/svn/repo1这里在/home/svn目录下创建了一个名为repo1 的版本库。 三、修改svn配置在创建完版本库后会在/svn /repo1/conf 目录下生成 passwd 、authz、svnserve.conf 三个文件。 3.1 修改 passwd 文件添加用户，设置用户密码，使用自带vim 进行编辑修改vi /home/svn/repo1/conf/passwd 12345678910### This file is an example password file for svnserve.### Its format is similar to that of svnserve.conf. As shown in the### example below it contains one section labelled [users].### The name and password for each user follow, one account per line.[users]# harry = harryssecret# sally = sallyssecret# 添加用户名密码也比较简单，使用vi指令直接插入 [username] = [password]，例如：username = password 3.2 修改 authz 文件对用户进行分组，以及配置用户读写权限vi /home/svn/repo1/conf/authz 1234567891011121314151617181920[aliases]# 对用户进行别名操作,这个感觉一般很少用,毕竟我们在设置的用户名一般就不会太长# joe = /C=XZ/ST=Dessert/L=Snake City/O=Snake Oil, Ltd./OU=Research Institute/CN=Joe Average[groups]# 对用户进行分组操作,如果用户比较的多，并且权限不一致的情况下,可以进行分组# 组名 = 用户名,用户名....# harry_and_sally = harry,sally# harry_sally_and_joe = harry,sally,&amp;joe[/]#具体的目录 /表示当前版本库,如果当前版本库中不同的文件夹需要区分不同的权限,可以具体的配置username = rw# 设置用户或者组的具体的权限。svn对权限的控制分为r(读)以及w(写)# 用户名/组名 = 具体的权限# &amp;joe = r#[repository:/]# @harry_and_sally = rw#* = rw 3.3 修改 svnserve.conf 文件，这是svn的具体配置文件，如果要使用到上面的 authz、 passwd，就需要修改配置该文件vi /home/svn/repo1/conf/authz 123456[general]anon-access = readauth-access = writepassword-db = passwdauthz-db = authz 3.4 配置完成，接下来就是开启svn的服务svnserve -d -r /home/svn/-d 指定svn在后台运行 -r 指定需要启动的版本库位置 如果需要停止svn服务,就需要执行下面的命令进行关闭 12ps -aux |grep svn #查找svn的进程idkill -9 进程id #直接关闭svn进程 到这一步基本的svn配置就完成了，可以通过svn客户端测试是否能够正常使用。 查看IP地址ip addr 通过svn客户端的svn checkout功能进行检出，项目svn地址为：svn://ip地址/版本库名称 四、开启防火墙端口开放假如你完成了以上配置仍然无法连接的话，那么可能是防火墙给拦截了，可以先试试关闭防火墙再测试（不建议正式环境下使用），或者开放svn的端口。 4.1 常用命令123456systemctl start firewalld #启动防火墙systemctl status firewalld #查看防火墙状态systemctl stop firewalld #关闭防火墙systemctl restart firewalld #重启防火墙systemctl enable firewalld.service #设置开机自启动systemctl disable firewalld.service #关闭开机自启动 4.2 开启svn的端口svn默认的端口是3690，在开启防火墙的同时支持svn外部访问只要执行以下步骤 12firewall-cmd --add-port=3690/tcp --permanent firewall-cmd --reload 4.3 关于防火墙配置的其他常用命令1234567891011firewall-cmd --state ##查看防火墙状态，是否是runningfirewall-cmd --reload ##重新载入配置，比如添加规则之后，需要执行此命令firewall-cmd --get-zones ##列出支持的zonefirewall-cmd --get-services ##列出支持的服务，在列表中的服务是放行的firewall-cmd --query-service ftp ##查看ftp服务是否支持，返回yes或者nofirewall-cmd --add-service=ftp ##临时开放ftp服务firewall-cmd --add-service=ftp --permanent ##永久开放ftp服务firewall-cmd --remove-service=ftp --permanent ##永久移除ftp服务firewall-cmd --add-port=80/tcp --permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的man firewall-cmd ##查看帮助 五、开机自启SVN5.1 在开机自动文件中添加svn服务修改自启文件 /etc/rc.d/rc.localvi /etc/rc.d/rc.local 123456# Please note that you must run &apos;chmod +x /etc/rc.d/rc.local&apos; to ensure# that this script will be executed during boot.touch /var/lock/subsys/local/usr/bin/svnserve -d -r /home/svn #指定svn路径 5.2 修改权限chmod -X /etc/rc.d/rc.local修改后还是访问不了，提示没有权限，可以试着关闭selinux。 5.3 关闭selinuxselinux 的开启，容易导致文件权限修改不了等问题，下面就是关闭设置selinux的方法。/usr/sbin/sestatus -v #查看selinux的开启状态修改/etc/selinux/config 文件vi /etc/selinux/config 12# mls - Multi Level Security protection.SELINUXTYPE=disabled #修改为disabled 重启系统即可 六、通过花生壳外网访问由于公用ip有限，现在大部分使用的都是动态ip，没有固定ip无法进行外网访问，这个时候我们需要做 端口映射，让外网也能访问到我们的svn。为什么使用花生壳呢，名声在外，自己做的怕安全不足。 6.1 使用端口映射跳过注册，下载软件部分，直接讲解使用花生壳的端口映射部分。内网主机填写的是虚拟机的内部IP，端口如果没有修改，默认使用的是3690。我们要映射的是svn的端口，所以这里选择应用类。端口映射也可以使用到挂载web项目上，如果需要使用web项目，需要修改映射类型。 6.2 外网访问地址使用客户端svn的svn checkout功能测试，访问地址 svn://外网访问/repo1（repo1为版本库名称）注意：外网访问地址要包括端口 七、附加说明7.1 更换虚拟分配的IP地址点击vmvare的编辑 - 虚拟网络编辑器直接修改子网ip，修改完记得重启。 7.2 应用svn的pre-commit以及post-commit在/svn/repo1/hooks目录下的 pree-commit 是作用是强制用户填写提交信息,以方便代码的管理。 123cp pre-commit.tmpl pre-commit #将该模板文件重命名为pre-commit文件chmod 755 pre-commit #对该文件添加可执行权限 vi /svn/repo1/hooks/pree-commit #修改pree-commit文件 修改后代码如下： 1234567891011#!/bin/shREPOS=&quot;$1&quot;TXN=&quot;$2&quot;SVNLOOK=svnlook #根据自己的具体情况,指定svnlook命令的具体的路径LOGMSG=`$SVNLOOK log -t &quot;$TXN&quot; &quot;$REPOS&quot; | grep &quot;[a-zA-Z0-9]&quot; | wc -c`#检测提交信息的长度,如果长度小于10个字符就报错if [ &quot;$LOGMSG&quot; -lt 10 ];then echo &quot;Log message can&apos;t be empty! you must input more than 10 chars as comment!.&quot; 1&gt;&amp;2 exit 1fi post-commit 则可以把我们提交后的文件自动更新到某一目录下。 123cp post-commit.tmpl post-commit #将该模板文件重命名为post-commit文件chmod 755 post-commit #对该文件添加可执行权限 vi /svn/repo1/hooks/post-commit #修改post-commit文件 修改后代码如下： 12345678REPOS=&quot;$1&quot;REV=&quot;$2&quot;#指定字符集,有的时候同步失败,可能就是字符集没有指定export LANG=&quot;zh_CN.UTF-8&quot; #调用svn update命令 将版本库中的文件同步到/home/svn/repo1文件中去#这里需要指定用户名以及密码svn update /home/svn/repo1 --username sunms --password james236 --no-auth-cache &gt;&gt; /var/svn-post.log 链接：https://pan.baidu.com/s/1r6Y4LeolSpnwrcWGPy_nHg提取码：yz8t","link":"","tags":[{"name":"linux","slug":"linux","permalink":"www.chenzhesheng.cc/tags/linux/"}]},{"title":"基于Ubuntu16.0.4版本linux系统下的腾讯云java后台服务器学习指南","date":"2018-03-17T08:21:37.000Z","path":"2018/03/17/基于Ubuntu16-0-4版本linux系统下的腾讯云java后台服务器学习指南/","text":"前言：本人于2018年03月06日购买了腾讯云服务器，用于java后台使用。由于是第一次使用，于是乎有了这篇文章。文章将直接跳过购买部分，来到配置java和后台环境部分。 使用工具：xshell、xftpxshell：可连接远程服务器，使用命令操作远程服务器xftp：用来向服务器传输文件 一、连接服务器。1.使用xshell连接服务器在腾讯云的管理页面找到购买的主机，设置用户名和密码，还有记住公网ip跟端口号。 打开xshell，输入服务器地址与端口号，点击连接，首次进入需输入用户名密码，这些在腾讯云后台可看到，记住密码则不用每次进入都输入。 2.重置root权限密码进入界面后，输入：sudo passwd输入新密码 + 回车 * 3次 3.获取usr用户根目录的权限root指令su root输入root密码 + 回车 二、配置java环境1.上传解压jdk环境压缩包1.1 创建java目录：mkdir /usr/local/java 1.2 在jdk官网下载好linux对应系统位数的安装包，使用xftp上传到服务器，shell指令复制到/usr/local/java目录下 1.3 使用cd进入到目录下解压sudo tar xvf jdk-8u121-linux-x64.tar.gz 1.4 删除原压缩包sudo rm jdk-8u121-linux-x64.tar.gz ###2.更改环境变量2.1 使用vim打开.bashrc环境配置文件sudo vim ~/.bashrc 2.2 在文件结尾添加（注意文件夹名字要匹配好jdk版本号）：export JAVA_HOME=/usr/local/java/jdk1.8.0_161export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 2.3 保存并退出,输入:wq回车 2.4 应用环境配置source ~/.bashrc 2.5 检验java环境是否配置好java -version返回： 123java version \"1.8.0_161\"Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode) 2.6 如果出现没有权限 Permission is not allowed,需要手动修改目录权限chmod 777 &lt;文件夹名&gt; 三、配置tomcat###1.下载解压安装包1.1 tomcat官网下载apache-tomcat-7.0.78.tar.gz 1.2 解压安装包tar -zxvf apache-tomcat-7.0.78.tar.gz 1.3 删除安装包sudo rm apache-tomcat-7.0.78.tar.gz ###2.修改启动器2.1 修改startup.sh 启动文件cd apche-tomcat-7.0.78/binsudo vim startup.sh 2.2 在esac下面添加：JAVA_HOME=/usr/local/java/jdk1.8.0_161JRE_HOME=/usr/local/java/jdk1.8.0_161/jrePATH=$JAVA_HOME/bin:$JRE_HOME:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarTOMCAT_HOME=/home/ubuntu/apache-tomcat-7.0.78 2.3 保存退出：:wq 2.4 启动tomcatsudo ./startup.sh返回 123456Using CATALINA_BASE: /home/ubuntu/apache-tomcat-7.0.85Using CATALINA_HOME: /home/ubuntu/apache-tomcat-7.0.85Using CATALINA_TMPDIR: /home/ubuntu/apache-tomcat-7.0.85/tempUsing JRE_HOME: /usr/local/java/jdk1.8.0_161Using CLASSPATH: /home/ubuntu/apache-tomcat-7.0.85/bin/bootstrap.jar:/home/ubuntu/apache-tomcat- 7.0.85/bin/tomcat-juli.jarTomcat started. 2.5 检查在浏览器输入localhost:8080，可以看到tomcat首页界面。 2.6 关闭tomcatsudo ./shutdown.sh 若是关闭tomcat出现 12Neither the JAVA_HOME nor the JRE_HOME environment variable is definedAt least one of these environment variable is needed to run this program 因为tomcat无法识别到环境变量，则需修改setclasspath.sh文件sudo vim setclasspath.sh 由于无法识别java_home和jre_home的环境变量，需要我们手动在文件头添加。 12JAVA_HOME=/usr/local/java/jdk1.8.0_161JRE_HOME=/usr/local/java/jdk1.8.0_161/jre 可以正常关闭tomcat，则说明修改完成。 四、配置mysql1.安装mysql1.1 linux安装mysql环境很简单，只需逐步执行以下指令即可。sudo apt-get install mysql-server 期间需要设置密码apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev 1.2 检查查看3306端口是否正常netstat -an | grep 3306如果处于listen则表示安装成功 1tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN 2.登录mysql数据库mysql -u root -p选择登录 -u 用户名为 root 输入密码 -p此时输入密码就可以登录mysql 12345678910111213Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 1705Server version: 5.7.21-0ubuntu0.16.04.1 (Ubuntu)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 3.创建远程访问mysql用户3.1 查询表显示当前的数据库show databases;显示当前数据库的表单show tables; 3.2 远程访问用户mysql默认是本机127.0.0.1访问数据库，想要远程访问需要开放mysql服务器并创建新的用户来访问mysql。 3.2.1 开放服务器修改配置文件：mysql5.7以下的的配置文件在/etc/mysql/my.cnf文件内，里面有一行bind-address = 127.0.0.1表示只允许本地访问，将它注释掉。mysql5.7版本或以上的配置文件在在/etc/mysql/mysql.conf.d目录下的mysqld.cnf文件 3.2.2 创建新用户赋予远程ip访问权限：查询mysql的用户表select user,authentication_string,host from mysql.user; 3.2.3 创建新用户grant all privileges on *.* to &#39;myuser&#39; @&#39;46.224.259.19&#39; identified by &#39;password&#39; with grant option;创建用户myuser使用password从ip 46.224.259.19连接到mysql服务器当然，ip 地址处可以修改为 ‘%’，指任意ip地址，实际环境不予许，慎用。 3.2.4 执行完之后需要执行flush privileges;，重新加载数据库。再查询一次： 12345678910+------------------+---------------+| user | host |+------------------+---------------+| myuser | 46.224.259.19 || debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost || root | localhost |+------------------+---------------+5 rows in set (0.00 sec) 3.2.5 退出 mysql&gt;quit; 退出mysql登录 3.2.6 再次查一下3306端口netstat -an | grep 3306 1tcp6 0 0 :::3306 :::* LISTEN ok 3.2.6 删除用户: mysql&gt;Delete FROM user Where User=&#39;myuser&#39; and Host=&#39;46.224.259.19&#39;;重新载入flush privileges; 4.启动数据库4.1 启动服务service mysql start4.2 停止service mysql stop4.3 重启service mysql restart 5.远程客户的Navicat for MySQL连接数据库主机名或地址：&lt;你的服务器地址&gt;端口：3306 （默认端口）用户名: &lt;mysql添加的用户名&gt;密码：&lt;用户名对应的密码&gt; ##总结1.需要学习xshell指令，才能更好的操作服务器。2.xftp非常方便使用，文件传输只需拖拽过去即可，上传，没有权限的需要解锁权限。3.操作usr目录需要root权限。4.服务器默认地址为localhost，需要手动修改，添加访问账号。5.Navicat 连接数据库出现“10061”，则是数据库不予许此ip地址访问，需要修改一下远程访问权限。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"www.chenzhesheng.cc/tags/linux/"}]}]